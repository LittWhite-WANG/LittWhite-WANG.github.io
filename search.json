[{"title":"Hello World","url":"/2023/08/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java极速版","url":"/2023/08/22/java%E6%9E%81%E9%80%9F%E7%89%88/","content":"java 学习笔记面向对象基础语法1、初识对象\n方法\n如果参数的类型(含义)相同，但是个数不确定的场合，JVM提供了可变参数 ： 参数的长度可变   参数类型…参数名\n\n\n\nvoid printUser( int age, String... name  ) &#123;        System.out.println(name);    &#125;\n\n\n静态方法\n\n成员方法可以访问静态属性和静态方法，但是静态方法不可以访问成员属性和成员方法\n\n\n静态代码块\n\n类的信息加载完成后，会自动调用静态代码块，可以完成静态属性的初始化功能\n\n对象准备创建时，也会自动调用代码块，但不是静态的\n\n\n\n\n2、构造方法、继承、多态\n构造方法\n\n构造方法也是方法，但是没有void关键字。\n方法名和类名完全相同\n如果类中没有构造方法，那么JVM会提供默认的构造方法\n如果类中有构造方法，那么JVM不会提供默认的构造方法\n构造方法也是方法，所以也可以传递参数，但是一般传递参数的目的是用于对象属性的赋值\n\n\n继承\n\n类存在父子关系：子类可以直接获取到父类的成员属性和成员方法。\n类的继承只能是单继承，一个类只能有一个父类，不能存在多个父类\n一个父类可以有多个子类\n如果父类和子类含有相同的属性，那么可以采用特殊的关键字进行区分:super &amp; this。但是上述关键字不能再静态代码中使用\n父类对象是在子类对象创建前创建完成，创建子类对象前，会调用父类的构造方法完成父类的创建\n默认情况下，子类对象构建时，会默认调用父类的构造方法完成父类对象的创建。使用的是super的方式，只不过JVM自动完成\n如果父类提供构造方法，那么JVM不会提供默认的构造方法，那么子类应该显示调用super方法构建父类对象。\n\n\n多态\n\n所谓的多态，其实就是一个对象在不同场景下表现出来的不同状态和形态，多态语法其实就是对对象的使用场景进行了约束，一个对象可以使用的功能取决于引用变量的类型。\n重载\n一个类中，不能重复声明的相同的方法，也不能声明相同的属性。这里相同的方法指的是方法名，参数列表相同，和返回值类型无关。 如果方法名相同，但是参数列表（个数，顺序，类型）不相同，会认为是不同的方法，只不过名称一样。 这个操作在Java称之方法的重载。\n构造方法也存在方法的重载\n如果在一个构造方法中。想要调用其他的构造方法，那么需要使用特殊的关键字：this，如this(“zhangsan”)，也就相当于有参构造。\n基本数据类型在匹配方法时，可以在数值不变的情况下，扩大数据的精度。\n引用数据类型在匹配方法时，可以在向父类寻找。\n\n\n方法的重写\n方法的重写：父类对象的方法其实主要体现通用性，无法在特殊的场合下使用， 如果子类对象需要在特殊的场合下使用，那么就需要重写方法的逻辑，这个操作在Java中称之为方法的重写。 这里的重写，并不意味着父类的方法被覆盖掉，只是在当前场合不使用。如果使用super关键字还是可以访问。\n方法的重写要求，子类的方法和父类的方法，方法名相同，返回值类型相同，参数列表要相同\n\n\n注意点：\n一个对象能使用什么方法，取决于引用变量的类型\n一个对象能使用什么属性，取决于引用变量的类型\n一个对象的方法具体的使用(直接，间接)是需要看具体的对象的\n一个对象的属性具体的使用是不需要看具体的对象的，属性在哪里声明在哪里使用\n\n\n\n\n访问权限\n\nJava中的访问权限主要分为4种：\n\nprivate : 私有的, 同一个类中可以使用\n(default) : 默认权限, 当不设定任何权限时，JVM会默认提供权限，包(路径)权限\nprotected : 受保护的权限, 子类可以访问\npublic : 公共的, 任意使用\n\n\npublic\n\n公共的，访问权限修饰符 。 Java的源码中，公共类只能有一个，而且必须和源码文件名相同。 \nmain方法：main方法是由JVM调用的，JVM调用时应该可以任意调用，而不用考虑权限问题。\n\n\nJava不允许外部类使用private, protected修饰。 所谓的外部类，就是在源码中直接声明的类。 所谓的内部类，就是类中声明的类\n\n单例模式\n\n类的创建过程复杂， 类的对象消耗资源，不希望创建太多实例\n\n\n\n  class User19 &#123;    private static User19 user19 = null;    private User19() &#123;    &#125;    public static User19 getInstance() &#123;        if ( user19 == null ) &#123;            user19 = new User19();        &#125;        return user19;    &#125;&#125;\n\nfinal关键字\n\nJava中提供了一种语法，可以在数据初始化后不被修改,使用关键字final\nfinal可以修饰变量：变量的值一旦初始化后无法修改\nfinal可以修饰属性：那么JVM无法自动进行初始化，需要自己进行初始化, 属性值不能发生变化\n一般将final修饰的变量称之为常量，或者叫不可变变量\nfinal可以修饰方法，这个方法不能被子类重写\nfinal可以修饰类，这样类就没有子类了\nfinal不可以修饰构造方法\nfinal可以修改方法的参数，一旦修饰，参数就无法修改。\n\n\n抽象（抽象类、抽象方法）\n\n抽象方法：只有声明，没有实现的方法。 abstract 返回值类型 方法名（参数）\n抽象类 : 不完整的类，就是抽象类。abstract class 类名。  因为类不完整，所以无法直接构造对象\n如果一个类中含有抽象方法，那么这个类是抽象类\n如果一个类是抽象类，它的方法不一定是抽象方法。\n抽象类无法直接构建对象，但是可以通过子类间接构建对象\n如果抽象类中含有抽象方法，那么子类继承抽象类，需要重写抽象方法，将方法补充完整。\n\n\n接口\n\n所谓的接口，可以简单理解为规则\n基本语法 ： interface 接口名称 { 规则属性，规则的行为 }\n接口其实是抽象的\n规则的属性必须为固定值，而且不能修改。\n属性和行为的访问权限必须为公共的。\n属性应该是静态的\n行为应该是抽象的\n接口和类是两个层面的东西\n接口可以继承其他接口\n类的对象需要遵循接口，在java中，这个遵循，称之为实现(implements)，类需要实现接口,而且可以实现多个接口\n\n\n枚举\n\n枚举是一个特殊的类，其中包含了一组特定的对象，这些对象不会发生改变, 一般都使用大写的标识符\n枚举使用enum关键字使用\n枚举类会将对象放置在最前面，那么和后面的语法需要使用分号隔开\n枚举类不能创建对象，它的对象是在内部自行创建\n\n\n匿名类\n\n在模型场合下，类的名字不重要，我们指向使用类中的方法或功能。那么此时我们可以采用特殊的语法：匿名类\n所谓的匿名类，就是没有名字的类\n\n\nBean规范\n\n主要用于编写逻辑，建立数据模型(Bean)\nBean类得设计规范：Bean规范\n类要求必须含有无参，公共得构造方法\n属性必须私有化，然后提供公共得，set，get方法\n\n\n作用域\n\n如果属性和（局部）变量的名称相同，访问时如果不加修饰符，那么优先访问变量。\n\n\n\n\n\n常见类和对象1、Object\ntoString方法默认返回内存地址\nhashCode()方法返回的也是内存地址\nequals()方法。判断两个对象是否相等, 如果相等，那么返回true，否则返回false。equals方法比较对象时，默认比较就是内存地址。\ngetClass获取对象的类型信息\n\n2、数组* \n3、字符串\n字符串拼接\n\n\n\n\n\na.concat(b)\n\n\n字符串比较\n\n相等a.equals(b)\n忽略大小写的相等：a.equalsIgnoreCase(b)\nint i&#x3D; a.compareTo(b)\ni &#x3D; 正数，a &gt; b\ni &#x3D; 负数，a &lt; b\ni &#x3D; 0, a &#x3D; b\n忽略大小写 int i &#x3D; a.compareToIgnoreCase(b)\n\n\n\n\n字符串截取\n\nstr.substring(a,b) a起始位置，b结束为止，不包括b ,也就是[a,b).\n如果只传递一个参数，那么就表示从指定位置开始截取字符串，然后截取到最后\n\n\n分解字符串\n\n根据指定的规则对字符串进行分解。可以将一个完整的字符串，分解成几个部分。\nString[] s1 &#x3D; s.split(“,”)\n\n\n去掉首位空格\n\ns.trim()\n\n\n字符串替换\n\ns.replace(traget, replacement)\n\ns.replaceAll()\n\n\n   String s = &quot;Hello World zhangsan&quot;; // Hello Java JavaSystem.out.println(s.replace(&quot;World zhangsan&quot;, &quot;Java&quot;));//replaceAll按照指定的规则进行替换System.out.println(s.replaceAll(&quot;World|zhangsan&quot;, &quot;Java&quot;));\n\n字符串的大小写转换\n\ns.toLowerCase()\ns.toUpperCase()\n\n\n字符串的查找\n\ns.charAt(1) charAt可以传递索引定位字符串中指定位置的字符\n\nindexof方法用于获取数据在字符串中第一次出现的位置\n\nlastIndexOf方法用于获取数据在字符串中最后一次出现的位置\n\n\n   // 是否包含指定的字符串，返回布尔类型System.out.println(s.contains(&quot;Hello123&quot;));// 判断字符串是否以指定的数据开头，返回布尔类型System.out.println(s.startsWith(&quot;Hello&quot;));// 判断字符串是否以指定的数据结尾，返回布尔类型System.out.println(s.endsWith(&quot;World&quot;));// 判断字符串是否为空，空格其实是一个特殊的字符，所以看不到，但是不为空。System.out.println(s.isEmpty());\n\nStringBuilder: 构建字符串\n   StringBuilder s = new StringBuilder();for ( int i = 0; i &lt; 100; i++ ) &#123;    s.append(i);&#125;System.out.println(s.toString());\n\n4、包装类 int i = 10;// TODO 将基本数据类型转换为包装类型// 自动装箱//Integer i1 = Integer.valueOf(i);Integer i1 = i;// 自动拆箱//int i2 = i1.intValue();int i2 = i1;\n\n5、日期类Date日期类 Date d = new Date();System.out.println(d);// Java格式化日期格式：// y (Y) -&gt; 年 -&gt; yyyy// m (M) -&gt; MM : 月份，mm:分钟// d (D) -&gt; dd : 一个月中的日期，D：一年中的日期// h (H) -&gt; h : 12进制， HH：24进制// s (S) -&gt; s : 秒，S :毫秒// Date -&gt; StringSimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);String dateFormatString = sdf.format(d);System.out.println(dateFormatString);// String -&gt; DateString dateString = &quot;2022-06-01&quot;;Date parseDate = sdf.parse(dateString);System.out.println(parseDate);// 根据时间戳构建指定的日期对象。//d.setTime(System.currentTimeMillis());// 获取时间戳//d.getTime();System.out.println(parseDate.before(d));System.out.println(parseDate.after(d));\n\nCalender日历类Calendar instance = Calendar.getInstance();//System.out.println(instance);System.out.println(instance.get(Calendar.YEAR));System.out.println(instance.get(Calendar.MONTH));System.out.println(instance.get(Calendar.DATE));//System.out.println(instance.get(Calendar.DAY));instance.setTime(new Date());instance.add(Calendar.YEAR, -1);\n\n异常java异常主要有两类\n\n可以通过代码恢复正常逻辑的异常,称之为运行期异常。（RuntimeException）\n不可以通过代码恢复正常逻辑的异常,称之为编译期期异常(Exception)\n\n基础语法 //try :尝试//catch :  捕捉//       捕捉多个异常的时候，需要先捕捉范围小的异常，然后再捕捉范围大的异常//finally : 最终try &#123;             可能会出现异常的代码             如果出现异常，那么JVM会将异常进行封装，形成一个具体的异常类，然后将这个异常抛出             所有的异常对象都可以被抛出         &#125; catch ( 抛出的异常对象 对象引用 ) &#123;             异常的解决方案            //e.getMessage() // 错误的消息            //e.getCause()\t// 错误的原因            //e.printStackTrace();         &#125; catch () &#123;         &#125; finally &#123;            最终执行的代码逻辑         &#125;\n\n\n常见异常\n\n除数为0的算术异常:java.lang.ArithmeticException\n空指针异常 : java.lang.NullPointerException。调用了一个为空（null）对象的成员属性或成员方法时，就会发生异常。\n索引越界 : ArrayIndexOutOfBoundsException\n字符串索引越界:StringIndexOutOfBoundsException\n格式化异常： NumberFormatException\n类型转换错误：java.lang.ClassCastException\n\n\n转换异常\n\n  // 如果方法中可能会出现问题，那么需要提前声明，告诉其他人，我的方法可能会出问题。\n  // 此时需要使用关键字throws\n  // 如果程序中需要手动抛出异常对象，那么需要使用throw关键字，然后new出异常对象\n  public void test( int i, int j ) throws Exception &#123;\n          try &#123;\n              System.out.println( i / j);\n          &#125; catch (ArithmeticException e) &#123;\n              throw new Exception();\n          &#125;\n  &#125;\n  * 自定义异常### 进阶语法-集合#### 介绍* Java中的集合是一个名词，数据的一种容器，用于容纳数据* 位于java.util包里 ```java\t// 问题：什么时候需要一个容纳数据的容器，也就是集合对象？\t//            Java集合框架中就包含了对不确定个数的数据处理的集合类\t// 问题：如果只是为了容纳数据，可以是直接使用数组，为什么要学习集合？\t//           数组使用起来不方便。在数据个数不确定的场合，数组使用起来不是很方便\t\t// 总结：对不确定的有关系的数据进行相同的逻辑处理的场合，使用集合是一个不错的选择\t\t// 根据数据的不同，Java的集合分为2大体系：\t// 1. 单一数据体系 ： Collection接口定义了相关的规则\t// 2. 成对出现的数据体系 ： Map接口定义了相关的规则\t//    所谓的成对的数据，就是2个数据有关系，可以根据第一个数据关联到第二个数据\t//    也称之为键值对数据 ，(123123, zhangsan) =&gt; (key, value)\n\n\n\n\n\n常用接口和类\nCollection接口\nList ：按照插入顺序保存数据，数据可以重复的\n具体的实现类： ArrayList, LinkedList\n\n\nSet : 集，无序保存，数据不能重复\n具体的实现类 HashSet\n\n\nQueue ： 队列\n\n  * 具体的实现类：ArrayBlockingQueue \n\n\nMap接口\n具体的实现 ： HashMap, Hashtable\n\n\n\nList\nArrayList\n\n基本操作\n\n   //创建第一个集合对象：ArrayListArrayList list = new ArrayList(3);// 1. 不需要传递构造参数，直接new就可以，底层数组为空数组// 2. 构造参数需要传递一个int类型的值，用于设定底层数组的长度// 3. 构造参数需要传递一个Collection集合类型的值，用于将其他集合中的数据放置在当前集合中// 增加数据// add方法可以增加数据，只要将数据作为参数传递到add方法即可// 添加数据时，如果集合中没有任何的数据，那么底层会创建长度为10的数组list.add(&quot;zhangsan&quot;);list.add(&quot;lisi&quot;);// 获取集合中数据的条数System.out.println(list.size());// 获取指定位置的数据，可以采用索引的方式System.out.println(list.get(1));// 遍历集合中的数据for ( int i = 0; i &lt; list.size(); i++ ) &#123;    //System.out.println(&quot;集合中的数据：&quot; + list.get(i));&#125;//如果循环遍历集合数据时，不关心数据的位置，那么可以采用特殊的for循环// for (循环对象：集合) &#123;&#125;for ( Object obj : list ) &#123;    System.out.println(&quot;集合中的数据：&quot; + obj);&#125;//修改数据// 将指定位置的数据进行修改,set方法需要传递2个参数，第一个参数表示数据的位置，第二个参数修改的值。// 方法会返回结果，这个结果就是更新前的值Object oldVal = list.set(1, &quot;lisi&quot;);System.out.println(&quot;修改前的值：&quot; + oldVal);//删除数据// 将指定位置的数据进行删除,remove方法需要传递1个参数，参数表示数据的位置。// 方法会返回结果，这个结果就是删除的值Object removeVal = list.remove(1);System.out.println(&quot;删除的值：&quot; + removeVal);//打印集合对象System.out.println(list);System.out.println(&quot;main方法执行完毕&quot;);\n\n\n常用方法\n  ArrayList list = new ArrayList();list.add(&quot;zhangsan&quot;);list.add(&quot;lisi&quot;);// add方法可以传递2个参数的，第一个参数表示数据增加的位置（索引），第二个参数表示数据list.add(1, &quot;zhaoliu&quot;);ArrayList otherList = new ArrayList();otherList.add(&quot;1&quot;);otherList.add(&quot;2&quot;);otherList.add(&quot;3&quot;);list.addAll( otherList );// size方法表示集合内部数据的数量//System.out.println(list.size());// 清空集合中的数据//list.clear();// 删除指定集合中的数据//list.removeAll(otherList);// 判断集合中的数据是否为空//System.out.println(list.isEmpty());// 用于判断集合中是否存在某条数据，返回布尔类型的值//System.out.println(list.contains(&quot;zhangsan123&quot;));// 用于获取数据在索引中的第一个位置，如果数据不存在，那么返回-1System.out.println(list.indexOf(&quot;zhangsan&quot;));//最后一个位置System.out.println(list.lastIndexOf(&quot;zhangsan&quot;));// 集合转数组Object[] objects = list.toArray();// 复制新集合Object clone = list.clone();ArrayList list1 = (ArrayList)clone;\n\n\n\nLinkedList\n基本操作\n  LinkedList list = new LinkedList();// 追加数据list.add(&quot;zhangsan&quot;);list.add(&quot;lisi&quot;);list.add(&quot;wangwu&quot;);//        // 想指定的位置增加数据//        list.add(1, &quot;zhaoliu&quot;);//        list.addFirst(&quot;1&quot;);//        list.addLast(&quot;2&quot;);////        LinkedList list1 = new LinkedList();//        list1.add(&quot;zhangsan1&quot;);//        list1.add(&quot;lisi2&quot;);//        list1.add(&quot;wangwu3&quot;);//        list.addAll(list1);//        System.out.println(list.remove(&quot;1&quot;));//        System.out.println(list.remove()); // 删除第一个//        list.removeFirst();//        list.removeLast();//        list.remove(1);System.out.println(list.size());System.out.println(list.isEmpty());//        list.clear();//        list.contains(&quot;1&quot;);//        list.element(); // 获取第一个数据//        list.indexOf(&quot;&quot;);//        list.lastIndexOf(&quot;&quot;);list.push(&quot;aaa&quot;); // 添加数据 添加到firstSystem.out.println(list.pop()); // 弹出数据 first\n\n泛型\n有时，也把泛型称之为类型参数\n类型约束外部类型，泛型约束内部类型\n类型存在多态的使用方式，但是泛型没有多态的概念\n比较器\n\npublic class Java08_Collection_Sort &#123;    public static void main(String[] args) &#123;        // Sort排序        ArrayList list = new ArrayList();        list.add(1);        list.add(3);        list.add(2);        // List对象进行排序，需要传递一个实现了比较器接口的对象        list.sort(new NumberComparator());        System.out.println(list);    &#125;&#125;class NumberComparator implements Comparator&lt;Integer&gt; &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        // TOD0如果第一个数比第二个数要大，那么返回结果为正数，表示升序l         // return o1 - o2;\t\t// TOD0如果第一个数比第二个数要小，那么返回结果为负数，表示降序        //return o2 - o1;\t\t// TOD0如果第一个数和第二个数一样大，那么返回结果为0        return 0;    &#125;&#125;\n\nArrayList和LinkedList的区别\n增加数据\n增加第一条数据，LinkedList会比ArrayList快\n增加第二条数据，ArrayList会比LinkedList快\n超过容量，LinkedList会比ArrayList快\n\n\n插入数据\n向指定位置插入数据或容量不够的情况下LinkedList更快\n\n\n查询数据\n索引查询ArrayList快\n无索引，没有本质区别\n\n\n\nHashSet\n常用方法\n\nHashSet set = new HashSet();// TODo 增加数据set.add(&quot;zhangsan&quot;);set.add(&quot;zhangsan&quot;);set.add(&quot;lisi&quot;);set.add(&quot;wangwu&quot;);// TODo 修改数据 不能直接修改，先删除再添加// TODo 删除数据//set.remove(&quot;wangwu&quot;);// TODo 查询数据，要遍历茶渣for (Object o : set) &#123;    System.out.println(o);&#125;ArrayList list = new ArrayList();list.add(&quot;zhangsan&quot;);list.add(&quot;lisi&quot;);list.add(&quot;wamngwu&quot;);set.addAll(list);Object[] objects = set.toArray();System.out.println(set.isEmpty());//set.clear();set.contains(&quot;zhangsan&quot;);System.out.println(set.size());Object clone = set.clone();System.out.println(clone);\n\n\n重复\n不包含重复数据\n复杂类型尽管属性相同，但是内存地址不同，因此不会被当做相同元素\n但是hashCode相同会被认为重复数据\n底层数据结构为数组+链表\n\n\n\nQueue\nArrayBlockingQueue： Array + Blocking(阻塞，堵住) + Queue\nqueue要指定容量，使用add和put超出容量会发生异常并且阻塞，但是使用offer方法会返回插入是否成功，并且不会阻塞\n取数据poll()取完数据不阻塞，take取数据会发生阻塞\n\nMapHashMap\n数据存储无序，没有重复数据\n\nHashMap&lt;String, String&gt; map = new HashMap();// 添加数据// 修改数据map.put(&quot;a&quot;, &quot;0&quot;);Object oldVal = map.put(&quot;a&quot;, &quot;1&quot;);//System.out.println(oldVal);// 添加数据map.putIfAbsent(&quot;b&quot;, &quot;2&quot;);map.putIfAbsent(&quot;b&quot;, &quot;3&quot;);Object b = map.replace(&quot;c&quot;, &quot;4&quot;);System.out.println(b);map.clear();map.put(&quot;zhangsan&quot;, &quot;1&quot;);map.put(&quot;lisi&quot;, &quot;2&quot;);map.put(&quot;wangwu&quot;, &quot;3&quot;);// TODO 获取map集合中所有的keySet set = map.keySet();for (Object k : set) &#123;    System.out.println(map.get(k));&#125;System.out.println(map.containsKey(&quot;zhangsan&quot;));Collection values = map.values();map.containsValue(&quot;1&quot;)// TODO 获取键值对对象Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();for (Map.Entry&lt;String, String&gt; entry : entries) &#123;    System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());&#125;map.remove(&quot;zhangsan&quot;);map.remove(&quot;zhangsan&quot;, &quot;1&quot;);map.size() ;map.isEmpty();map.clear();map.clone();System.out.println(map);\n\nHashTable\n和HashMap的不同点\n\n  1. 实现方式不一样的 ： 继承父类不一样\n  2. 底层结构的容量不同： HashMap(16), Hashtable(11)\n  3. HashMap的K,V都可以为null, Hashtable的K, V不能是null\n  4. HashMap的数据定位采用的是Hash算法，但是Hashtable采用的就是hashcode\n  5. HashMap的性能较高，但是Hashtable较低(多线程时，Hashtable更安全)\n\n\n\n\n\n"}]